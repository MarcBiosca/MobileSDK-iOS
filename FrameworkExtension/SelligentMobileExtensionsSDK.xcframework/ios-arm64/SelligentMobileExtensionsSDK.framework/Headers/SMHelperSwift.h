#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
#ifndef SELLIGENTMOBILEEXTENSIONSSDK_SWIFT_H
#define SELLIGENTMOBILEEXTENSIONSSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wduplicate-method-match"
#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if defined(__cplusplus)
#if !defined(SWIFT_NOEXCEPT)
# define SWIFT_NOEXCEPT noexcept
#endif
#else
#if !defined(SWIFT_NOEXCEPT)
# define SWIFT_NOEXCEPT 
#endif
#endif
#if defined(__cplusplus)
#if !defined(SWIFT_CXX_INT_DEFINED)
#define SWIFT_CXX_INT_DEFINED
namespace swift {
using Int = ptrdiff_t;
using UInt = size_t;
}
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreFoundation;
@import CoreLocation;
@import Foundation;
@import MapKit;
@import ObjectiveC;
@import UIKit;
@import UserNotifications;
@import UserNotificationsUI;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="SelligentMobileExtensionsSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)





SWIFT_PROTOCOL("_TtP28SelligentMobileExtensionsSDK28NotificationSettingsProtocol_")
@protocol NotificationSettingsProtocol
@property (nonatomic, readonly) UNAuthorizationStatus authorizationStatus;
@end

@class NSString;
@class NSDate;
enum kSMNotificationMessageType_ : NSInteger;
@class NSCoder;

SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK13SMBaseMessage")
@interface SMBaseMessage : NSObject <NSSecureCoding>
/// Indicates whether NSSecureCoding is supported
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
/// String value of the message Id
@property (nonatomic, readonly, copy) NSString * _Nonnull idMessage;
/// Date value of the message reception date
@property (nonatomic, copy) NSDate * _Nonnull receptionDate;
/// Date value of the message expiration date, if any
@property (nonatomic, readonly, copy) NSDate * _Nullable expirationDate;
/// Date value of the message creation date
@property (nonatomic, readonly, copy) NSDate * _Nonnull creationDate;
/// Bool value indication whether the message has been viewed (at least once), or not
@property (nonatomic, readonly) BOOL isViewed;
/// The inapp-message type (if any)
@property (nonatomic, readonly) enum kSMNotificationMessageType_ type;
/// Inherited from NSCoding.encode(with:)
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
/// Inherited from NSCoding.encode(with:)
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
/// Returns an integer that can be used as a table address in a hash table structure
@property (nonatomic, readonly) NSUInteger hash;
/// Returns a Boolean value that indicates whether the receiver and a given object are equal
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


typedef SWIFT_ENUM_NAMED(NSInteger, kSMClearCache_, "SMClearCache", open) {
/// This explicitly disables the SDK-cache mechanism
  kSMClearCache_None = 0,
/// Default value, the SDK will automatically decide the best setting
  kSMClearCache_Auto = 1,
/// Clear the cache weekly
  kSMClearCache_Week = 2,
/// Clear the cache monthly
  kSMClearCache_Month = 3,
/// Clear the cache quarterly
  kSMClearCache_Quarter = 4,
};


SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK11SMConstants")
@interface SMConstants : NSObject
/// Domain used by the SDK for custom error handling
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kSMErrorDomain;)
+ (NSString * _Nonnull)kSMErrorDomain SWIFT_WARN_UNUSED_RESULT;
/// It is broadcasted when the user interacts with a Remote Notification. It can be used to retrieve user action on a received remote-notification
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kSMNotification_Event_ButtonClicked;)
+ (NSString * _Nonnull)kSMNotification_Event_ButtonClicked SWIFT_WARN_UNUSED_RESULT;
/// It is broadcasted shortly before displaying a Remote Notification’s content. It can be used to pause any ongoing work before the Remote Notification is displayed. This notification-name is also triggered even if you disable <code>SMManagerSetting/shouldDisplayRemoteNotification</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kSMNotification_Event_WillDisplayNotification;)
+ (NSString * _Nonnull)kSMNotification_Event_WillDisplayNotification SWIFT_WARN_UNUSED_RESULT;
/// It is broadcasted shortly before dismissing the current Remote Notification’s content. It can be used to resume any paused work
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kSMNotification_Event_WillDismissNotification;)
+ (NSString * _Nonnull)kSMNotification_Event_WillDismissNotification SWIFT_WARN_UNUSED_RESULT;
/// It is broadcasted shortly after receiving a Remote Notification. It can be used to decide when to display a remote-notification
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kSMNotification_Event_DidReceiveRemoteNotification;)
+ (NSString * _Nonnull)kSMNotification_Event_DidReceiveRemoteNotification SWIFT_WARN_UNUSED_RESULT;
/// It is broadcasted shortly after receiving in-app messages. It can be used to manage the received in-app messages
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kSMNotification_Event_DidReceiveInAppMessage;)
+ (NSString * _Nonnull)kSMNotification_Event_DidReceiveInAppMessage SWIFT_WARN_UNUSED_RESULT;
/// It is broadcasted shortly after receiving in-app contents
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kSMNotification_Event_DidReceiveInAppContent;)
+ (NSString * _Nonnull)kSMNotification_Event_DidReceiveInAppContent SWIFT_WARN_UNUSED_RESULT;
/// It is broadcasted shortly after receiving a Marigold Engage deviceId value. It can be used to manage the received device id
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kSMNotification_Event_DidReceiveDeviceId;)
+ (NSString * _Nonnull)kSMNotification_Event_DidReceiveDeviceId SWIFT_WARN_UNUSED_RESULT;
/// Use this Key to retrieve the object <code>SMLink</code>, from the NSNotification-name <code>SMConstants/kSMNotification_Event_ButtonClicked</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kSMNotification_Data_ButtonData;)
+ (NSString * _Nonnull)kSMNotification_Data_ButtonData SWIFT_WARN_UNUSED_RESULT;
/// Use this Key to retrieve a Dictionary instance with the Push Id and title, from the NSNotification-name <code>SMConstants/kSMNotification_Event_DidReceiveRemoteNotification</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kSMNotification_Data_RemoteNotification SWIFT_DEPRECATED_MSG("Deprecated, use `SMConstants/kSMNotification_Object_RemoteNotification` instead which returns an SMNotificationMessage");)
+ (NSString * _Nonnull)kSMNotification_Data_RemoteNotification SWIFT_WARN_UNUSED_RESULT;
/// Use this Key to retrieve an SMNotificationMessage instance with the Push content, from the NSNotification-name <code>SMConstants/kSMNotification_Event_DidReceiveRemoteNotification</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kSMNotification_Object_RemoteNotification;)
+ (NSString * _Nonnull)kSMNotification_Object_RemoteNotification SWIFT_WARN_UNUSED_RESULT;
/// Use this Key to retrieve an Array instance with Dictionary instances containing  id and title as properties, from the NSNotification-name <code>SMConstants/kSMNotification_Event_DidReceiveInAppMessage</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kSMNotification_Data_InAppMessage SWIFT_DEPRECATED_MSG("Deprecated, use `SMConstants/kSMNotification_Object_InAppMessage` instead which returns an SMInAppMessage");)
+ (NSString * _Nonnull)kSMNotification_Data_InAppMessage SWIFT_WARN_UNUSED_RESULT;
/// Use this Key to retrieve an SMInAppMessage instance with the message content, from the NSNotification-name <code>SMConstants/kSMNotification_Event_DidReceiveInAppMessage</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kSMNotification_Object_InAppMessage;)
+ (NSString * _Nonnull)kSMNotification_Object_InAppMessage SWIFT_WARN_UNUSED_RESULT;
/// Use this Key to retrieve an Array instance of <code>SMInAppContentMessage</code>, from the NSNotification-name <code>SMConstants/kSMNotification_Event_DidReceiveInAppContent</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kSMNotification_Data_InAppContent;)
+ (NSString * _Nonnull)kSMNotification_Data_InAppContent SWIFT_WARN_UNUSED_RESULT;
/// Use this Key to retrieve an <code>String</code> instance with the Marigold Engage deviceId value, from the NSNotification-name <code>SMConstants/kSMNotification_Event_DidReceiveDeviceId</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kSMNotification_Data_DeviceId;)
+ (NSString * _Nonnull)kSMNotification_Data_DeviceId SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end








typedef SWIFT_ENUM_NAMED(NSInteger, kSMDisplayMode_, "SMDisplayMode", open) {
/// When the value is not contained in this enum, it will be unknown
  kSMDisplayMode_Unknown = -1,
/// Display only once
  kSMDisplayMode_OnlyOnce = 0,
/// Always display until replaced
  kSMDisplayMode_UntilReplaced = 1,
};

typedef SWIFT_ENUM(NSInteger, SMError, open) {
/// Some function parameters are missing
  SMErrorMissingParameters = 1000,
/// Some function parameters are wrongly formatted
  SMErrorWrongParameters = 1001,
/// Some settings at app level are missing or wrong
  SMErrorWrongAppSettings = 2000,
};

@class SMSuccess;
@class SMFailure;

SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK7SMEvent")
@interface SMEvent : NSObject <NSSecureCoding>
/// Indicates whether NSSecureCoding is supported
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
/// Confirm if the current event should be cached or not
/// If the event fail to be delivered to your backend, then by default, it is cached into an internal queue.
/// After a while, the library will automaticly try to send it again.
/// Should you want to prevent this behavior, feel free to set this property to <em>false</em>.
/// By default, it is set to <em>true</em>
@property (nonatomic) BOOL shouldCache;
/// Create an event object that will be sent to platform
/// \param name The name for the custom event (currently not sent to the backend, future-proof property), used to identify what the event needs to do at server side
///
/// \param profileId The custom profile identifier (<code>mail</code> in our v1 platform) of the user
///
/// \param properties A dictionary containing any kind of custom data that must be stored and managed by platform
///
- (nonnull instancetype)initWithName:(NSString * _Nonnull)name profileId:(NSString * _Nonnull)profileId properties:(NSDictionary * _Nullable)properties OBJC_DESIGNATED_INITIALIZER;
/// Allow to initialize a success block and/or a failure block that will be triggered after an event is sent to the platform
/// \param successBlock Void that gives an <code>SMSuccess</code> if the event was sent properly to the platform
///
/// \param failureBlock Void that gives an <code>SMFailure</code> if the event sendout to the platform returned any error
///
- (void)applyWithSuccessBlock:(void (^ _Nullable)(SMSuccess * _Nonnull))successBlock failureBlock:(void (^ _Nullable)(SMFailure * _Nonnull))failureBlock;
/// Inherited from NSCoding.encode(with:).
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
/// Inherited from NSCoding.encode(with:).
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
/// A textual representation of the receiver.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK13SMEventAction")
@interface SMEventAction : SMEvent
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithName:(NSString * _Nonnull)name profileId:(NSString * _Nonnull)profileId properties:(NSDictionary * _Nullable)properties SWIFT_UNAVAILABLE;
@end


SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK20SMEventButtonClicked")
@interface SMEventButtonClicked : SMEventAction
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK17SMEventPushOpened")
@interface SMEventPushOpened : SMEventAction
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK19SMEventPushReceived")
@interface SMEventPushReceived : SMEventAction
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_PROTOCOL("_TtP28SelligentMobileExtensionsSDK13SMEventSystem_")
@protocol SMEventSystem
@end


SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK11SMEventUser")
@interface SMEventUser : SMEvent
/// Indicates whether NSSecureCoding is supported
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithName:(NSString * _Nonnull)name profileId:(NSString * _Nonnull)profileId properties:(NSDictionary * _Nullable)properties SWIFT_UNAVAILABLE;
@end


SWIFT_PROTOCOL("_TtP28SelligentMobileExtensionsSDK9SMMessage_")
@protocol SMMessage
/// String value of the message description
@property (nonatomic, readonly, copy) NSString * _Nonnull messageSM;
@end


SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK9SMFailure")
@interface SMFailure : NSObject <SMMessage>
/// Description of the failure
@property (nonatomic, readonly, copy) NSString * _Nonnull messageSM;
/// Description of the failure
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK14SMHttpResponse")
@interface SMHttpResponse : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class SMNotificationAnnotationData;
@class SMLink;

SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK14SMInAppMessage")
@interface SMInAppMessage : SMBaseMessage
/// Indicates whether NSSecureCoding is supported
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
/// String value providing the title of the message
@property (nonatomic, readonly, copy) NSString * _Nonnull title;
/// String value providing the content of the message
@property (nonatomic, readonly, copy) NSString * _Nonnull body;
/// The anotations for map type messages
@property (nonatomic, readonly, copy) NSArray<SMNotificationAnnotationData *> * _Nonnull arrayMapAnnotations;
/// Links that the message can contain
@property (nonatomic, readonly, copy) NSArray<SMLink *> * _Nonnull arrayIAMLinks;
/// String value providing the title of the remote-notification
@property (nonatomic, readonly, copy) NSString * _Nonnull apsTitle;
/// String value providing the body of the remote-notification
@property (nonatomic, readonly, copy) NSString * _Nonnull apsBody;
/// String value providing the metadata content defined when sending out the communication
@property (nonatomic, readonly, copy) NSString * _Nonnull metadata;
/// String array value providing the tag values defined when sending out the communication)
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull tags;
/// String value providing the profile defined when sending out the communication
@property (nonatomic, readonly, copy) NSString * _Nonnull profileId;
/// Inherited from NSCoding.encode(with:)
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
/// Inherited from NSCoding.encode(with:)
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end



typedef SWIFT_ENUM_NAMED(NSInteger, kSMInAppMessageServiceState_, "SMInAppMessageServiceState", open) {
/// In-app message service hasn’t been explicitly enabled or disabled just yet, thus it will remain disabled from an operational point of view
  kSMInAppMessageServiceState_Undefined = 0,
/// In-app message service has explicitly been disabled
  kSMInAppMessageServiceState_Disabled = 1,
/// In-app message service has explicitly been enabled
  kSMInAppMessageServiceState_Enabled = 2,
};

enum kSMNotificationButtonType_ : NSInteger;

SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK6SMLink")
@interface SMLink : NSObject <NSSecureCoding>
/// Indicates whether NSSecureCoding is supported
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
/// String value providing the id of the button
@property (nonatomic, copy) NSString * _Nonnull idButtonData;
/// String value providing the label of the button
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
/// String value providing the value of the button
@property (nonatomic, readonly, copy) NSString * _Nonnull value;
/// The type of action the button will execute
@property (nonatomic, readonly) enum kSMNotificationButtonType_ type;
/// Inherited from NSCoding.encode(with:)
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
/// Inherited from NSCoding.encode(with:)
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@interface SMLink (SWIFT_EXTENSION(SelligentMobileExtensionsSDK))
- (void)updateLinkAndProcessFrom:(SMBaseMessage * _Nonnull)message;
- (void)processData;
@end


typedef SWIFT_ENUM_NAMED(NSInteger, kSMLogLevel_, "SMLogLevel", open) {
/// No log printed at all.
/// This is the suggested log-level for release.
  kSMLogLevel_None = 0,
/// Default log-entry.
/// Basically inform user when library starts / ends.
  kSMLogLevel_Info = 1,
/// Only warning messages are printed
  kSMLogLevel_Warning = 2,
/// Only Error messages are being printed
  kSMLogLevel_Error = 3,
/// Print only HTTP-requests stuff
  kSMLogLevel_HttpCall = 4,
/// Print everything. Do not use for release!
  kSMLogLevel_All = -1,
};


SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK9SMManager")
@interface SMManager : NSObject
/// The current version of the library
@property (nonatomic, readonly, copy) NSString * _Nonnull versionLib;
/// Currently known Marigold Engage device Id
@property (nonatomic, readonly, copy) NSString * _Nonnull deviceId;
/// Singleton for <code>SMManager</code> which allows to access public methods and properties
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) SMManager * _Nonnull shared;)
+ (SMManager * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


@interface SMManager (SWIFT_EXTENSION(SelligentMobileExtensionsSDK))
/// Send an event to the Marigold Engage platform
/// \param event <code>SMEvent</code> object with your event.
///
- (void)send:(SMEvent * _Nonnull)event;
@end


@interface SMManager (SWIFT_EXTENSION(SelligentMobileExtensionsSDK))
/// Set the log level of the library console.
/// This is an optional setting that may help you debug the library calls.
/// This call can be done at any time (before or after starting the library).
/// However, in order to avoid missing any error log, we recommand setting this value before starting the library.
/// warning:
/// It is developer’s responsability to enable log-level in Debug or release mode.  For obvious performance reason, it is always recommended to turn log off in release mode.
/// \param logLevel Specify the appropiate <code>SMLogLevel</code> for the SDK to use.
///
- (void)apply:(enum kSMLogLevel_)logLevel;
@end



@class UNMutableNotificationContent;
@class UNNotificationContent;

@interface SMManager (SWIFT_EXTENSION(SelligentMobileExtensionsSDK))
- (void)setNotificationAsEncryptedWithBestAttemptContent:(UNMutableNotificationContent * _Nonnull)bestAttemptContent contentHandler:(void (^ _Nullable)(UNNotificationContent * _Nonnull))contentHandler;
@end


@interface SMManager (SWIFT_EXTENSION(SelligentMobileExtensionsSDK))
- (void)getProfileWithCompletion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(void))failure;
@end

@class SMManagerSetting;
@class UNNotificationResponse;
@class UNNotification;
@class NSExtensionContext;
@class UNNotificationRequest;
@class SMNotificationMessage;

@interface SMManager (SWIFT_EXTENSION(SelligentMobileExtensionsSDK))
/// Mandatory API when using Notification Extensions.
/// To be included in didReceiveNotification: when implementing Notification content extension and/or in the didReceiveNotificationRequest:withContentHandler: when implementing Notification service extension.
/// \param with <code>SMManagerSetting</code> instance to start-up the library
///
- (void)startExtensionWith:(SMManagerSetting * _Nonnull)settings;
/// Optional API when using a Notification content extension, to be included in didReceiveNotificationResponse:completionHandler: if you want the action buttons to be processed without opening the main App.
/// Handles remote notification actions.
/// \param response An UNNotificationResponse that contains information about the notification and the interaction the user has done with it, provided by the delegate call
///
/// \param completionHandler A completion that will be called with the option UNNotificationContentExtensionResponseOptionDismiss, provided by the delegate call
///
- (void)didReceive:(UNNotificationResponse * _Nonnull)response completionHandler:(void (^ _Nonnull)(UNNotificationContentExtensionResponseOption))completionHandler SWIFT_AVAILABILITY(maccatalyst,introduced=14.0);
/// Mandatory API when using a Notification content extension, to be included in didReceiveNotification:.
/// Handles the push action buttons and rich content that may be present in the Marigold Engage notification payload.
/// \param notification An UNNotification that contains information about the notification
///
/// \param context An NSExtensionContext that contains the context information of the extension
///
- (void)didReceive:(UNNotification * _Nonnull)notification context:(NSExtensionContext * _Nullable)context;
/// Optional API when using a Notification service extension, to be included in didReceiveNotificationRequest:withContentHandler:.
/// This allows the SDK to decrypt the payload before displaying it to the user if you have activated the encryption of push, and send the proper push received event to the platform.
/// \param request An UNNotificationRequest that contains the original notification request
///
/// \param completion A completion block returning the UNMutableNotificationContent that contains the modified notification content
///
- (void)didReceiveWithRequest:(UNNotificationRequest * _Nonnull)request completion:(void (^ _Nonnull)(UNMutableNotificationContent * _Nonnull))completion;
/// Optional API when using a Notification service extension, to be included in didReceiveNotificationRequest:withContentHandler:.
/// This allows the SDK to decrypt the payload before displaying it to the user if you have activated the encryption of push, and send the proper push received event to the platform.
/// \param request An UNNotificationRequest that contains the original notification request
///
/// \param contentHandler The block to execute with the modified content
///
- (void)didReceive:(UNNotificationRequest * _Nonnull)request contentHandler:(void (^ _Nonnull)(UNNotificationContent * _Nonnull))contentHandler;
/// Optional API when using a Notification service extension, to be included in serviceExtensionTimeWillExpire.
/// Tells the SDK that the extension is about to be terminated.
/// warning:
/// Do not implement this if you are not using the encryption functionality or you didn’t implement the <code>SMManager/didReceive(_:contentHandler:)</code>
- (void)serviceExtensionTimeWillExpire;
/// Optional API, retrieves the <code>SMNotificationMessage</code> object from a given userInfo.
/// To be used for custom implementations when you need to get the Marigold Engage push object from the provided userInfo to know what has been provided from the backend and use it.
///
/// returns:
/// <code>SMNotificationMessage</code> instance containing the information extracted from the given userInfo. Returns nil if the given userInfo is not a valid Marigold Engage notification.
- (SMNotificationMessage * _Nullable)retrieveNotificationMessage:(NSDictionary * _Nonnull)userInfo SWIFT_WARN_UNUSED_RESULT;
@end



SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK16SMManagerSetting")
@interface SMManagerSetting : NSObject
/// This value tells how often the SDK’s cache mechanism should clear itself.
/// Internally, each notification-messages has a life-span.
/// Clearing the cache stands for deleting notification-messages with an expired life-span.
/// In other words, only old notification-messages are deleted from the cache.
/// More recent ones are kept in memory until their life-span expires and a new clearCache is called.
/// By default, this value is set to <em>kSMClearCache_Auto</em>.
/// warning:
/// In 99% of the cases, you should not overide this property as the SDK is smart enough to handle the cache mechanism by itself.
@property (nonatomic) enum kSMClearCache_ clearCacheIntervalValue;
/// This value provides to the SDK  the app group id that you have previously defined in your apple developer portal.
/// It is used to allow the SDK to share data between the main app and the notification extensions (service and/or content).
/// The deviceId provided by Marigold Engage mobile platform is stored in this container
@property (nonatomic, copy) NSString * _Nonnull appGroupId;
/// Marigold Engage v1 support. Use this init when integrating with the old system.
/// Default-mandatory constructor to start the <code>SMManager</code> shared instance
/// \param url The endpoint of Marigold Engage mobile servers backend
///
/// \param clientId Marigold Engage’s mobile app Id to secure requests
///
/// \param privateKey Marigold Engage’s mobile app Id to secure requests
///
///
/// throws:
/// NSError (where the <em>domain</em> will be <code>SMConstants/kSMErrorDomain</code> and the <em>code</em> will be one from <code>SMError</code>). Possible thrown codes for this method: <code>SMError/wrongParameters</code> (when any of the mandatory parameters are missing)
- (nullable instancetype)initWithUrl:(NSString * _Nonnull)url clientId:(NSString * _Nonnull)clientId privateKey:(NSString * _Nonnull)privateKey error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Engage Delivery Cloud support. Use this init when integrating with the new system.
/// Default-mandatory constructor to start the <code>SMManager</code> shared instance
/// \param url The endpoint of Marigold Engage mobile servers backend
///
/// \param appId The main app bundle Id
///
/// \param apiKey Marigold Engage mobile apiKey to secure requests
///
/// \param legacyPrivateKey Valid privateKey from Marigold Engage v1 mobile platform (if any)
///
///
/// throws:
/// NSError (where the <em>domain</em> will be <code>SMConstants/kSMErrorDomain</code> and the <em>code</em> will be one from <code>SMError</code>). Possible thrown codes for this method: <code>SMError/wrongParameters</code> (when any of the mandatory parameters are missing)
- (nullable instancetype)initWithUrl:(NSString * _Nonnull)url appId:(NSString * _Nonnull)appId apiKey:(NSString * _Nonnull)apiKey legacyPrivateKey:(NSString * _Nullable)legacyPrivateKey error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@class NSURL;

SWIFT_PROTOCOL("_TtP28SelligentMobileExtensionsSDK31SMManagerUniversalLinksDelegate_")
@protocol SMManagerUniversalLinksDelegate
/// Invoked when a `deeplink button type, whose URL scheme is HTTP or HTTPS, is clicked
/// \param url The URL introduced as the value of the button that has been clicked
///
- (void)executeLinkAction:(NSURL * _Nonnull)url;
@end


typedef SWIFT_ENUM_NAMED(NSInteger, kSMMN_, "SMMessageNature", open) {
/// Message origin from push notification
  kSMMN_Push = 0,
/// Message origin from in-app content
  kSMMN_IaContent = 1,
/// Message origin from push in-app message
  kSMMN_IaMessage = 2,
};


SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK28SMNotificationAnnotationData")
@interface SMNotificationAnnotationData : NSObject <NSSecureCoding, MKAnnotation>
/// Indicates whether NSSecureCoding is supported
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
/// CLLocationCoordinate2D instance providing the annotation’s coordinate
/// *
@property (nonatomic, readonly) CLLocationCoordinate2D coordinate;
/// String value providing the annotation’s title
/// *
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/// String value providing the annotation’s subtitle
/// *
@property (nonatomic, readonly, copy) NSString * _Nullable subtitle;
/// Inherited from NSCoding.encode(with:)
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
/// Inherited from NSCoding.encode(with:)
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


typedef SWIFT_ENUM_NAMED(NSInteger, kSMNotificationButtonType_, "SMNotificationButtonType", open) {
/// Any received button-type not in this enumeration will be considered as unknown
  kSMNotificationButtonType_Unknown = -1,
/// A button-type that will have no action but when will send back a Clicked event to the platform
  kSMNotificationButtonType_Simple = 0,
/// A button-type that will open the phone application with a ready to use number to dial
  kSMNotificationButtonType_OpenPhoneCall = 1,
/// A button-type that will open the sms application with a ready to dial sms
  kSMNotificationButtonType_OpenSms = 2,
/// A button-type that will open the mail application with a ready to send email address
  kSMNotificationButtonType_OpenMail = 3,
/// A button-type that will open safari with a specific URL
  kSMNotificationButtonType_OpenBrowser = 4,
/// A button-type that will open a third party application
  kSMNotificationButtonType_OpenApplication = 5,
/// A button-type which will allow application rating.
  kSMNotificationButtonType_RateApplication = 6,
/// A button-type that will trigger a notification inside the application for any interested listener.
/// You may register in your application to a specific event from NSNotificationCenter. The notification is broadcasted as soon as button is clicked.
/// Your back-end team should inform you about the notification-name.
  kSMNotificationButtonType_CustomActionBroadcastEvent = 7,
/// A button-type which will allow to open a pkpass file
  kSMNotificationButtonType_Passbook = 11,
/// A button-type which will allow user to execute a depplink
  kSMNotificationButtonType_DeepLink = 13,
};

@class NSBundle;
@class UIColor;

SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK35SMNotificationContentViewController")
@interface SMNotificationContentViewController : UIViewController <UNNotificationContentExtension>
/// <code>SMManagerSetting</code> object that will be used when dealing with the extension behaviour
@property (nonatomic, strong) SMManagerSetting * _Nullable settings;
/// Whether clicking in a notification button should (always) open the App first, default true.
/// If set to false, actions that do not need the app to be opened to be executed, won’t open it (i.e Open Url, Deeplink, Mail, SMS…)
@property (nonatomic) BOOL notificationButtonClicksShouldOpenTheApp;
/// Default initializer called by UNNotificationContentExtension
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
/// Inherited from NSCoding.encode(with:).
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER SWIFT_UNAVAILABLE_MSG("This class does not support NSCoding");
/// Handles the UNNotificationContentExtension behaviour when a push is to be expanded
/// \param notification The given <code>UNNotification</code> object
///
- (void)didReceiveNotification:(UNNotification * _Nonnull)notification;
/// Handles the UNNotificationContentExtension behaviour when clicking in a notification button
/// \param response The given <code>UNNotificationResponse</code> object
///
/// \param completion The given <code>(UNNotificationContentExtensionResponseOption) -> Void</code> object
///
- (void)didReceiveNotificationResponse:(UNNotificationResponse * _Nonnull)response completionHandler:(void (^ _Nonnull)(UNNotificationContentExtensionResponseOption))completion SWIFT_AVAILABILITY(maccatalyst,introduced=14.0);
/// Called after the view has been loaded. For view controllers created in code, this is after -loadView. For view controllers unarchived from a nib, this is after the view is set.
- (void)viewDidLoad;
/// Called when the view is about to be dismissed, covered, or otherwise hidden.
- (void)viewWillDisappear:(BOOL)animated;
/// Implement this property when you want the system to display a media playback button in your notification interface. Return an appropriate constant indicating the type of button you want.
@property (nonatomic, readonly) UNNotificationContentExtensionMediaPlayPauseButtonType mediaPlayPauseButtonType SWIFT_AVAILABILITY(maccatalyst,introduced=14.0) SWIFT_AVAILABILITY(maccatalyst_app_extension,introduced=14.0);
/// The tint color for the media playback button.
@property (nonatomic, readonly, strong) UIColor * _Nonnull mediaPlayPauseButtonTintColor;
/// The frame rectangle to use for displaying a media playback button.
@property (nonatomic, readonly) CGRect mediaPlayPauseButtonFrame;
/// Tells you to begin playback of your media content.
- (void)mediaPlay;
/// Tells you to pause playback of your media content.
- (void)mediaPause;
@end


typedef SWIFT_ENUM_NAMED(NSInteger, kSMNotificationMediaType_, "SMNotificationMediaType", open) {
/// When the value is not contained in this enum, it will be unknown
  kSMNotificationMediaType_Unknown = -1,
/// Audio media type
  kSMNotificationMediaType_Audio = 2,
/// Image media type
  kSMNotificationMediaType_Image = 3,
/// Video media type
  kSMNotificationMediaType_Video = 4,
};


SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK21SMNotificationMessage")
@interface SMNotificationMessage : SMInAppMessage
/// Indicates whether NSSecureCoding is supported
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
/// The type of rich media that the notification has
@property (nonatomic, readonly) enum kSMNotificationMediaType_ mediaType;
/// String value providing the title of the message
@property (nonatomic, readonly, copy) NSString * _Nonnull mediaUrl;
/// The link behind the main action of the remote notification
@property (nonatomic, readonly, strong) SMLink * _Nullable mainAction;
/// Links that the remote notification has
@property (nonatomic, readonly, copy) NSArray<SMLink *> * _Nonnull notificationButtons;
/// Inherited from NSCoding.encode(with:)
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
/// Inherited from NSCoding.encode(with:)
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM_NAMED(NSInteger, kSMNotificationMessageType_, "SMNotificationMessageType", open) {
/// When the value is not contained in this enum, it will be unknown
  kSMNotificationMessageType_Unknown = -2,
/// In App message of hidden type
  kSMNotificationMessageType_Hidden = -1,
/// In App message of alert type
  kSMNotificationMessageType_Alert = 0,
/// In App message of html type
  kSMNotificationMessageType_Html = 1,
/// In App message of url type
  kSMNotificationMessageType_Url = 2,
/// In App message of image type
  kSMNotificationMessageType_Image = 3,
/// In App message of map type
  kSMNotificationMessageType_Map = 4,
/// In App message of passbook type
  kSMNotificationMessageType_Passbook = 5,
};


SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK21SMNotificationService")
@interface SMNotificationService : UNNotificationServiceExtension
/// <code>SMManagerSetting</code> object that will be used when dealing with the extension behaviour
@property (nonatomic, strong) SMManagerSetting * _Nullable settings;
/// Whether encryption is enabled or not (needs to be aligned with the Marigold Engage backend configuration), default false
@property (nonatomic) BOOL encryptionEnabled;
/// Handles the UNNotificationServiceExtension behaviour when a push is received
/// \param request The given <code>UNNotificationRequest</code> object
///
/// \param contentHandler The given <code>(UNNotificationContent) -> Void</code> object
///
- (void)didReceiveNotificationRequest:(UNNotificationRequest * _Nonnull)request withContentHandler:(void (^ _Nonnull)(UNNotificationContent * _Nonnull))contentHandler;
/// If encryption is enabled and the process times out, the push content will be marked as “(Encrypted)” before being delivered to the user
- (void)serviceExtensionTimeWillExpire;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM_NAMED(NSInteger, kSMRemoteMessageDisplayType_, "SMRemoteMessageDisplayType", open) {
/// Default value when not explicitly set
  kSMRemoteMessageDisplayType_Unknown = 0,
/// No Push nor in-app messages will be displayed
  kSMRemoteMessageDisplayType_None = 1,
/// A Push notification will be displayed
  kSMRemoteMessageDisplayType_Notification = 2,
/// An in-app message will be displayed (when there is an in-app message available within the remote-notification payload)
  kSMRemoteMessageDisplayType_Automatic = 3,
};


SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK9SMSuccess")
@interface SMSuccess : NSObject <SMMessage>
/// Description of the success
@property (nonatomic, readonly, copy) NSString * _Nonnull messageSM;
/// Description of the success
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


@class UIImage;

SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK13SMUIImageView")
@interface SMUIImageView : UIImageView
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER SWIFT_UNAVAILABLE_MSG("This class does not support NSCoding");
- (nonnull instancetype)initWithImage:(UIImage * _Nullable)image OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithImage:(UIImage * _Nullable)image highlightedImage:(UIImage * _Nullable)highlightedImage SWIFT_UNAVAILABLE;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end


SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK8SMUIView")
@interface SMUIView : UIView
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER SWIFT_UNAVAILABLE_MSG("This class does not support NSCoding");
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC28SelligentMobileExtensionsSDK18SMUIViewController")
@interface SMUIViewController : UIViewController
/// Inherited from NSCoding.encode(with:)
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER SWIFT_UNAVAILABLE_MSG("This class does not support NSCoding");
/// Creates a view controller with the nib file in the specified bundle
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
@end

@class UIWindowScene;
@class UIWindow;

SWIFT_PROTOCOL("_TtP28SelligentMobileExtensionsSDK21UIApplicationProtocol_")
@protocol UIApplicationProtocol
@property (nonatomic, readonly, strong) UIWindowScene * _Nullable currentWindowScene SWIFT_AVAILABILITY(ios,introduced=13.0);
@property (nonatomic, readonly, strong) UIWindow * _Nullable currentWindow;
@property (nonatomic, readonly) UIApplicationState applicationState;
@property (nonatomic) NSInteger applicationIconBadgeNumber;
- (UIBackgroundTaskIdentifier)beginBackgroundTaskWithName:(NSString * _Nullable)taskName expirationHandler:(void (^ _Nullable)(void))handler SWIFT_WARN_UNUSED_RESULT;
- (void)endBackgroundTask:(UIBackgroundTaskIdentifier)identifier;
- (void)setMinimumBackgroundFetchInterval:(NSTimeInterval)minimumBackgroundFetchInterval;
- (void)registerForRemoteNotifications;
@end


@interface UIApplication (SWIFT_EXTENSION(SelligentMobileExtensionsSDK)) <UIApplicationProtocol>
@property (nonatomic, readonly, strong) UIWindowScene * _Nullable currentWindowScene SWIFT_AVAILABILITY(maccatalyst,introduced=13.1) SWIFT_AVAILABILITY(ios,introduced=13.0);
@property (nonatomic, readonly, strong) UIWindow * _Nullable currentWindow;
@end









@interface UNNotificationSettings (SWIFT_EXTENSION(SelligentMobileExtensionsSDK)) <NotificationSettingsProtocol>
@end

@class UNNotificationCategory;

SWIFT_PROTOCOL("_TtP28SelligentMobileExtensionsSDK30UserNotificationCenterProtocol_")
@protocol UserNotificationCenterProtocol
- (void)removeAllPendingNotificationRequests;
- (void)setNotificationCategories:(NSSet<UNNotificationCategory *> * _Nonnull)categories;
- (void)requestAuthorizationWithOptions:(UNAuthorizationOptions)options completionHandler:(void (^ _Nonnull)(BOOL, NSError * _Nullable))completionHandler;
- (void)getCustomNotificationSettingsWithCompletionHandler:(void (^ _Nonnull)(id <NotificationSettingsProtocol> _Nonnull))completionHandler;
- (void)getNotificationCategoriesWithCompletionHandler:(void (^ _Nonnull)(NSSet<UNNotificationCategory *> * _Nonnull))completionHandler;
- (void)scheduleLocalNotification:(UNNotificationRequest * _Nonnull)request completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
@end


@interface UNUserNotificationCenter (SWIFT_EXTENSION(SelligentMobileExtensionsSDK)) <UserNotificationCenterProtocol>
- (void)getCustomNotificationSettingsWithCompletionHandler:(void (^ _Nonnull)(id <NotificationSettingsProtocol> _Nonnull))completionHandler;
- (void)scheduleLocalNotification:(UNNotificationRequest * _Nonnull)request completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
@end




#endif
#if defined(__cplusplus)
#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
